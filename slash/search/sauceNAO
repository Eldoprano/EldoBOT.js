const slashCommand = require('../../base/slashCommand.js');
const sagiri = require('sagiri');
const config = require('../../config.js');
const { MessageActionRow, MessageButton, MessageEmbed } = require('discord.js');
const https = require('https');


const sauceNAO_token = config.sauceNAO_token;
const sauceNAO_client = sagiri(sauceNAO_token);

function makeEmbed(sauceNAO_element, pageNumber, emb_user) {
  const result_data = sauceNAO_element.raw.data;
  const emb_similarity = sauceNAO_element.raw.header.similarity;
  let emb_preview, emb_index_saucenao, emb_link, emb_artist, emb_name,
    emb_episode, statusCode, emb_character, emb_company, emb_game,
    emb_description, emb_color, emb_embbed_tittle, emb_footer;

  if ('thumbnail' in sauceNAO_element.raw.header) {
    emb_preview = sauceNAO_element.raw.header.thumbnail;
  }

  if (emb_similarity > 50) {
    emb_index_saucenao = sauceNAO_element.raw.header.index_name.split('-')[0];

    // Test if URL is still working
    statusCode = getUrlStatusCode(result_data.ext_urls[0]);
    if (statusCode != 404) {
      emb_link = result_data.ext_urls[0];
    }
    // Check Pixiv
    if ('pixiv_id' in result_data) {
      emb_artist = result_data.member_name;
    }
    // Check Nijie
    else if ('nijie_id' in result_data) {
      emb_name = result_data.title;
      emb_artist = result_data.member_name;
    }

    // Check for other sources
    else if ('source' in result_data) {
      if ('part' in result_data) {
        emb_name = result_data.source;
        emb_episode = result_data.part;
      } else if (result_data.source.search('twitter.com') != -1) {
        emb_artist = result_data.creator;
      }
      if ('material' in result_data) {
        emb_name = result_data.material;
      }
      if (getUrlStatusCode(result_data.source) != 404) {
        emb_link = result_data.source;
      } else {
        emb_link = '**Link del Twitt original caído**';
      }
    }

    // Check for Sankaku/Gelbooru/Konachan
    else if ('sankaku_id' in result_data ||
      'gelbooru_id' in result_data ||
      'konachan_id' in result_data) {

      if ('creator' in result_data) {
        if (result_data.creator == '') {
          if (result_data.material != '') {
            emb_name = result_data.material.split(',')[0];
          }
        }
      }
      if (result_data.characters != '') {
        emb_character = result_data.characters;
      }
      if ('material' in result_data) {
        if (result_data.material == 'original') {
          if ('characters' in result_data) {
            if (result_data.characters != '') {
              emb_character = result_data.characters;
            }
          }
        } else if (result_data.material != '') {
          emb_name = result_data.material;
        }
      }
      if (result_data.creator != '') {
        emb_artist = result_data.creator;
      }
    }

    if ('getchu_id' in result_data) {
      emb_company = result_data.company;
      emb_game = result_data.title;
    }

    // Fill unfilled data
    if (emb_name == '') {
      try {
        if ('title_english' in result_data) {
          emb_name = result_data['title_english'];
        } else {
          emb_name = result_data['title'];
        }
      } catch (e) {
        // ignore error
      }
    }
    if (emb_artist == '') {
      try {
        if (result_data.creator instanceof Array) {
          for (const artist of result_data.creator) {
            emb_artist += artist + ', ';
          }
          emb_artist = emb_artist.slice(0, -2);
        } else {
          emb_artist = result_data['creator'];
        }
      } catch (e) {
        // Ignore error
       }
    }

    if (emb_character == '') {
      try {
        emb_character = result_data['characters'];
      } catch (e) {
        // Ignore error
      }
    }
    if (emb_link == '') {
      try {
        if ('mal_id' in result_data) {
          emb_link = 'https://myanimelist.net/anime/' + result_data['mal_id'];
        } else if (result_data.ext_urls instanceof Array) {
          emb_link = result_data.ext_urls[0];
        } else {
          emb_link = result_data.ext_urls;
        }
      } catch (e) {
        // Ignore error
      }
    }

    if (emb_link == '') {
      try {
        if (result_data.ext_urls instanceof Array) {
          emb_link = result_data.ext_urls[0];
        } else {
          emb_link = result_data.ext_urls;
        }
      } catch (e) {
        // Ignore error
       }
    }
    if (emb_name == '') {
      try {
        emb_name = result_data.eng_name;
      } catch (e) {
        // Ignore error
      }
    }

    if (emb_episode == '' && 'episode' in result_data) {
      emb_episode = result_data.episode;
    }
  } // END of "if (similarity_of_result > 50)"

  // We should already have all the data at this point, so we create the message
  if (emb_name != '' || emb_artist != '' || emb_link != '') {
    emb_description = '';
    if (emb_name != '') {
      emb_description += '**Nombre: ** ' + emb_name + '\n';
    }
    if (emb_episode != '') {
      emb_description += '**Episodio: ** ' + emb_episode + '\n';
    }
    if (emb_character != '') {
      emb_description += '**Personaje: ** ' + emb_character + '\n';
    }
    if (emb_artist != '') {
      emb_description += '**Artista: ** ' + emb_artist + '\n';
    }
    if (emb_company != '') {
      emb_description += '**Compañía: ** ' + emb_company + '\n';
    }
    if (emb_game != '') {
      emb_description += '**Juego: ** ' + emb_game + '\n';
    }
    if (emb_link != '') {
      emb_description += '**Link: ** ' + emb_link + '\n';
    }

    emb_description += '**Encontrado en: **' + emb_index_saucenao + '\n';

    if (emb_similarity > 89) {
      emb_color = 1425173; // A nice green
      emb_embbed_tittle = 'Nombre encontrado!';
    } else if (emb_similarity > 65) {
      emb_color = 16776960; // An insecure yellow
      emb_embbed_tittle = 'Nombre quizás encontrado!';
    } else {
      emb_color = 15597568; // A worrying red
      emb_embbed_tittle = 'Nombre probablemente encontrado!';
    }
    emb_footer = 'Porcentaje de seguridad: ' + emb_similarity + '% | Pedido por: ' + emb_user + ' | Page ' + pageNumber;
  }

  const embedWithResults = new MessageEmbed()
    .setDescription(emb_description)
    .setTitle(emb_embbed_tittle)
    .setColor(emb_color)
    .setFooter(emb_footer);
  if (emb_preview) {
    embedWithResults.setImage(emb_preview);
  }
  return embedWithResults;


  function getUrlStatusCode(url) {

    try {
      https.get(url, (resp) => {
        return resp.statusCode;
      }).on('error', (err) => {
        console.log('HTTP Error: ' + err.message);
        return 404;
      });
    } catch (e) {
      console.log(e);
      return 404;
    }
  }
}

module.exports = class sauceNAO extends slashCommand {

  constructor(client) {
    super(client, {
      name: 'name',
      description: 'Searches the origin of an image',
      options: [],
      guildOnly: true, // Set this to false if you want it to be global.
    });
  }

  async run(client, interaction) {
    try {
      await interaction.deferReply();

      const results = await sauceNAO_client('https://media.discordapp.net/attachments/653348223901237250/886391161172946944/unknown.png');
      let currentResultPage = 0;

      // console.log(results);
      const pageButtons = new MessageActionRow()
                            .addComponents(
                              new MessageButton()
                                .setCustomId('previous')
                                .setLabel('PREVIOUS')
                                .setStyle('PRIMARY'))
                            .addComponents(
                              new MessageButton()
                                .setCustomId('next')
                                .setLabel('NEXT')
                                .setStyle('PRIMARY'),
                            );

      console.log('INTERACTION', interaction);
      let currentPage = await interaction.editReply({
        embeds: [makeEmbed(results[currentResultPage], currentResultPage, interaction.member.displayName)],
        components: [pageButtons],
        fetchReply: true,
      });

      const collector = await currentPage.createMessageComponentCollector({ componentType: 'BUTTON', time: 300000 });

      collector.on('collect', async (i) => {
        // console.log('WARE WARE COLLECTOR',i)
        switch (i.customId) {
          case 'previous':
            if (currentResultPage <= 0) {
              currentResultPage = results.length;
            } else {
              currentResultPage -= 1;
            }
            break;
          case 'next':
            if (currentResultPage >= results.length - 1) {
              currentResultPage = 0;
            } else {
              currentResultPage += 1;
            }
            break;
          default:
            break;
        }
        i.deferUpdate();
        currentPage = await interaction.editReply({ embeds: [makeEmbed(results[currentResultPage], currentResultPage, interaction.member.displayName)], components: [pageButtons] });
      });

    } catch (e) {
      console.log(e);
      return await interaction.editReply(`There was a problem with your request.\n\`\`\`${e.message}\`\`\``);
    }
  }
};